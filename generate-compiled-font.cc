
#include <assert.h>
#include <libgen.h>
#include <stdint.h>
#include <string.h>
#include <strings.h>

#include <string>
#include <set>

#include "bdf-font.h"
#include "utf8-internal.h"

// params:
// fontname, fontname, fontname, page, width, glyphs,
// fontname, fontname, fontname
// (Darn, there should be a better templating ...)
static constexpr char kHeaderTemplate[] =
    R"(// -*- mode: c++; c-basic-offset: 2; indent-tabs-mode: nil; -*-
// This is autogenerated.
#ifndef FONT_%s_
#define FONT_%s_

#include "font-support.h"

struct ProgmemFont_%s_t {
  struct MetaFont meta;
  struct {
    struct MetaGlyph meta;
    uint8_t data[%d][%d];  // page-stripes, width
  } glyphs[%d];
} __attribute__((packed));

extern const struct ProgmemFont_%s_t PROGMEM progmem_font_%s;
#define font_%s (&progmem_font_%s.meta)

#endif // FONT_%s_
)";

static constexpr char kCodeTemplate[] =
    R"(// -*- mode: c; c-basic-offset: 2; indent-tabs-mode: nil; -*-
// DO NOT EDIT: autogenerated from %s
// for characters "%s"

#include "font-%s.h"

// We're linking this in a pure C compilation unit as C++ as of now officially
// does not support readability-improving designated initializers. Sigh.
const struct ProgmemFont_%s_t PROGMEM progmem_font_%s = {
  .meta = { .available_glyphs = %d, .pages = %d, .font_width = %d,
            .glyph_data_size = %d },
  .glyphs = {
    )";

static int usage(const char *prog) {
    fprintf(stderr, "usage: %s <bdf-file> <fontname> <relevantchars>\n", prog);
    fprintf(stderr, "ouputs font-$(fontname).h font-$(fontname).c\n"
            "containting relevant characters\n");
    return 1;
}

class CollectFontMeta : public BitCanvas {
public:
    void SetPixel(int x, int y, bool) {
        if (x >= width_) width_ = x+1;
        if (y >= max_height_) max_height_ = y;
        if (y < min_height_) min_height_ = y;
        //printf("(%d,%d) h=%d\n", x, y, max_height_ - min_height_);
    }
    void NextChar() { count_++; }

    int width() const { return width_; }
    int pages() const { return (max_height_ - min_height_ +8)/8; }
    int offset_y() const { return min_height_; }

private:
    int width_ = -1;
    int min_height_ = 1000;
    int max_height_ = -1;
    int count_ = 0;
};

class GlyphEmitter : public BitCanvas {
public:
    GlyphEmitter(FILE *out,
                 int font_width, int offset_y, int pages)
        : out_(out),
          font_width_(font_width), offset_y_(offset_y), pages_(pages),
          data_(new uint8_t [font_width_ * pages_]) {
        Reset();
    }

    void SetPixel(int x, int y, bool on) final {
        if (x >= glyph_width_) glyph_width_ = x+1;
        if (!on) return;
        y -= offset_y_;
        assert(y >= 0);
        int page = y / 8;
        int bit = y % 8;
        data_[page * font_width_ + x] |= (1 << bit);
    }

    void EmitChar(uint16_t codepoint) {
        if (codepoint < 0x80) {
            fprintf(out_, R"({
      .meta = {.codepoint = '%s%c', .width=%d},
      .data = {)",
                    codepoint == '\'' ? "\\" : "", codepoint,
                    glyph_width_ < 0 ? font_width_ : glyph_width_);
        } else {
            fprintf(out_, R"({
      .meta = {.codepoint = 0x%04x, .width=%d},
      .data = {)",
                    codepoint,
                    glyph_width_ < 0 ? font_width_ : glyph_width_);
        }
        for (int p = 0; p < pages_; ++p) {
            fprintf(out_, "{");
            for (int x = 0; x < glyph_width_; ++x) {
                if (x != 0) fprintf(out_, ", ");
                if (x > 0 && x % 8 == 0)
                    fprintf(out_, "\n                ");
                fprintf(out_, "0x%02x", data_[p * font_width_ + x]);
            }
            if (p == pages_-1)
                fprintf(out_, "}");
            else
                fprintf(out_, "},\n               ");
        }
        fprintf(out_, "}\n    },");
        Reset();
    }

private:
    void Reset() {
        bzero(data_, pages_ * font_width_);
        glyph_width_ = -1;
    }

    FILE *const out_;
    const int font_width_;
    const int offset_y_;
    const int pages_;
    int glyph_width_;
    uint8_t *data_;
};

int main(int argc, char *argv[]) {
    if (argc <= 3) return usage(argv[0]);

    const char *const bdf_font = argv[1];
    const char *const fontname = argv[2];
    const char *const utf8_text = argv[3];

    Font font;
    if (!font.LoadFont(bdf_font)) {
        fprintf(stderr, "Couldn't load font %s\n", bdf_font);
        return usage(argv[0]);
    }

    std::set<uint16_t> relevant_chars;
    for (const char *utfchars = utf8_text; *utfchars; /**/) {
        const uint32_t cp = utf8_next_codepoint(utfchars);
        relevant_chars.insert(cp);
    }

    if (relevant_chars.empty()) {
        fprintf(stderr, "relevant chars is empty?. Not creating output\n");
        return usage(argv[0]);
    }

    CollectFontMeta meta_collector;
    for (auto c : relevant_chars) {
        font.DrawGlyph(&meta_collector, 0, font.baseline(), false, c);
        meta_collector.NextChar();
    }


    std::string header_filename = std::string("font-") + fontname + ".h";
    FILE *header = fopen(header_filename.c_str(), "w");
    fprintf(header, kHeaderTemplate,
            fontname, fontname, fontname,
            meta_collector.pages(), meta_collector.width(),
            (int)relevant_chars.size(),
            fontname, fontname, fontname, fontname, fontname);
    fclose(header);

    std::string code_filename = std::string("font-") + fontname + ".c";
    FILE *code_file = fopen(code_filename.c_str(), "w");
    fprintf(code_file, kCodeTemplate, basename(strdup(bdf_font)), utf8_text,
            fontname, fontname, fontname,
        (int)relevant_chars.size(), meta_collector.pages(),
        meta_collector.width(),
        meta_collector.width() * meta_collector.pages() + 3/* sizeof(MetaFont)*/
        );
    GlyphEmitter glyph_emitter(code_file,
                               meta_collector.width(),
                               meta_collector.offset_y(),
                               meta_collector.pages());
    for (auto c : relevant_chars) {
        font.DrawGlyph(&glyph_emitter, 0, font.baseline(), false, c);
        glyph_emitter.EmitChar(c);
    }
    fprintf(code_file, "\n  }\n};\n");
    fclose(code_file);
}
